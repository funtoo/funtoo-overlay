diff -rupN PyQwt-5.2.0/sip/qwt5qt4/QwtStack.sip PyQwt-5.2.0-new/sip/qwt5qt4/QwtStack.sip
--- PyQwt-5.2.0/sip/qwt5qt4/QwtStack.sip	2008-07-26 19:27:16.000000000 +0200
+++ PyQwt-5.2.0-new/sip/qwt5qt4/QwtStack.sip	2017-01-04 19:27:08.358712518 +0100
@@ -1,5 +1,5 @@
 // The SIP interface specification for:
-//      QStack<Type>.
+//      QStack<TYPE>.
 //
 // Copyright (C) 2001-2007 Gerard Vermeulen
 // Copyright (C) 2000 Mark Colclough
@@ -30,9 +30,9 @@
 // PyQwt becomes a free plug-in for a non-free program.
 
 
-// QStack<Type> is implemented as a Python list.
-template<Type>
-%MappedType QStack<Type>
+// QStack<TYPE> is implemented as a Python list.
+template<TYPE>
+%MappedType QStack<TYPE>
 {
 %TypeHeaderCode
 #include <qstack.h>
@@ -46,8 +46,8 @@ template<Type>
 
     // Set the list elements.
     for (int i=0; i<sipCpp->size(); ++i) {
-        Type *t = new Type(sipCpp->at(i));
-        PyObject *o = sipConvertFromNewInstance(t, sipClass_Type, sipTransferObj);
+        TYPE *t = new TYPE(sipCpp->at(i));
+        PyObject *o = sipConvertFromNewType(t, sipType_TYPE, sipTransferObj);
         if (0 == o) {
             Py_XDECREF(o);
             Py_DECREF(l);
@@ -66,30 +66,30 @@ template<Type>
             return 0;
         // check elements
         for (int i = 0; i < PyList_GET_SIZE(sipPy); ++i)
-            if (!sipCanConvertToInstance(PyList_GET_ITEM(sipPy, i), sipClass_Type, 0))
+            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i), sipType_TYPE, 0))
                 return 0;
         return 1;
     }
 
     // Return the QStack.
-    QStack<Type> *s = new QStack<Type>;
+    QStack<TYPE> *s = new QStack<TYPE>;
     for (int i = 0; i < PyList_GET_SIZE(sipPy); ++i) {
         int state;
-        Type *t = reinterpret_cast<Type *>(sipConvertToInstance(PyList_GET_ITEM(sipPy, i), sipClass_Type, 0, SIP_NOT_NONE, &state, sipIsErr));
+        TYPE *t = reinterpret_cast<TYPE *>(sipConvertToType(PyList_GET_ITEM(sipPy, i), sipType_TYPE, 0, SIP_NOT_NONE, &state, sipIsErr));
 
         if (*sipIsErr) {
-            sipReleaseInstance(t, sipClass_Type, state);
+            sipReleaseType(t, sipType_TYPE, state);
             delete s;
             return 0;
         }
         s->append(*t);
-        sipReleaseInstance(t, sipClass_Type, state);
+        sipReleaseType(t, sipType_TYPE, state);
     }
     *sipCppPtr = s;
 
     return sipGetState(sipTransferObj);
 %End
-}; // template<Type> %MappedType QStack<Type>
+}; // template<TYPE> %MappedType QStack<TYPE>
 
 
 // Local Variables:
