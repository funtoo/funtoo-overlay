diff -rupN PyQwt-5.2.0/sip/qwt5qt3/common/QwtValueStack.sip PyQwt-5.2.0-new/sip/qwt5qt3/common/QwtValueStack.sip
--- PyQwt-5.2.0/sip/qwt5qt3/common/QwtValueStack.sip	2009-02-17 10:55:14.000000000 +0100
+++ PyQwt-5.2.0-new/sip/qwt5qt3/common/QwtValueStack.sip	2017-01-04 19:29:49.823341913 +0100
@@ -1,5 +1,5 @@
 // The SIP interface specification for:
-//      QValueStack<Type>.
+//      QValueStack<TYPE>.
 //
 // Copyright (C) 2001-2009 Gerard Vermeulen
 // Copyright (C) 2000 Mark Colclough
@@ -30,9 +30,9 @@
 // PyQwt becomes a free plug-in for a non-free program.
 
 
-// QValueStack<Type> is implemented as a Python list.
-template<Type>
-%MappedType QValueStack<Type>
+// QValueStack<TYPE> is implemented as a Python list.
+template<TYPE>
+%MappedType QValueStack<TYPE>
 {
 %TypeHeaderCode
 #include <qvaluestack.h>
@@ -46,10 +46,10 @@ template<Type>
 
     // Set the list elements.
     int i = 0;
-    QValueListConstIterator<Type> it;
+    QValueListConstIterator<TYPE> it;
     for (it = sipCpp->begin(); it != sipCpp->end(); ++it) {
         PyObject *o;
-        if (0 == (o = sipConvertFromInstance(new Type(*it), sipClass_Type, sipTransferObj))
+        if (0 == (o = sipConvertFromType(new TYPE(*it), sipType_TYPE, sipTransferObj))
             || 0 > PyList_SetItem(l, i, o)) {
             Py_XDECREF(o);
             Py_DECREF(l);
@@ -68,33 +68,33 @@ template<Type>
             return 0;
         // check elements
         for (int i = 0; i < PyList_GET_SIZE(sipPy); ++i)
-            if (!sipCanConvertToInstance(PyList_GET_ITEM(sipPy, i), sipClass_Type, 0))
+            if (!sipCanConvertToType(PyList_GET_ITEM(sipPy, i), sipType_TYPE, 0))
                 return 0;
         return 1;
     }
 
     // Return the QValueStack.
-    QValueStack<Type> *s = new QValueStack<Type>;
+    QValueStack<TYPE> *s = new QValueStack<TYPE>;
     for (int i = 0; i < PyList_GET_SIZE(sipPy); ++i) {
         int iserr = 0, state;
 
-        Type *t = reinterpret_cast<Type *>(sipConvertToInstance(PyList_GET_ITEM(sipPy, i), sipClass_Type, 0, SIP_NOT_NONE, &state, &iserr));
+        TYPE *t = reinterpret_cast<TYPE *>(sipConvertToType(PyList_GET_ITEM(sipPy, i), sipType_TYPE, 0, SIP_NOT_NONE, &state, &iserr));
 
         if (iserr) {
-            sipReleaseInstance(t, sipClass_Type, state);
+            sipReleaseType(t, sipType_TYPE, state);
             *sipIsErr = 1;
             delete s;
             
             return 0;
         }
         s->append(*t);
-        sipReleaseInstance(t, sipClass_Type, state);
+        sipReleaseType(t, sipType_TYPE, state);
     }
     *sipCppPtr = s;    
     
     return sipGetState(sipTransferObj);
 %End
-}; // template<Type> %MappedType QValueStack<Type>
+}; // template<TYPE> %MappedType QValueStack<TYPE>
 
 
 // Local Variables:
